# Copyright 2017 Andrew Rucker Jones.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

bean.descriptors.uninitialized=Map der Bean-Deskriptoren konnte nicht initialisiert werden.
collection.cannot.be.instantiated=Ein Sammeltyp des Typs [%s] kann mit Null-Argument-Konstruktor nicht instantiiert werden.
column.count.mismatch=Die Anzahl der Spaltennamen muss mit der Anzahl der \u00dcberschriftnamen \u00fcbereinstimmen.
column.name.bogus=Spalten d\u00fcrfen nicht null oder leer sein, oder nur aus Leerzeichen bestehen.
column.nonexistant=Die Spalte namens %s existiert nicht im Ergebnissatz!
conversion.impossible=Konvertierung von %1$s in %2$s fehlgeschlagen.
csvdate.not.date=Annotation @CsvDate f\u00fcr ein Feld nicht zeitlichen Typs verwendet.
csvnumber.not.number=Die Annotation CsvNumber wurde für einen Typ angewendet, der nicht von java.lang.Number abgeleitet ist.
csvreader.null=IterableCSVToBeanBuilder konnte deshalb nicht instatiiert werden, weil noch kein CSVReader definiert ist.
custom.converter.invalid=Der Eigenkonvertierer %s konnte nicht instantiiert werden.
define.separator=Das Trennzeichen muss definiert sein!
error.introspecting.beans=Es gab beim Manipulieren der zu schreibenden Bean einen Fehler.
error.introspecting.field=Ein Introspektionsfehler ist beim Versuch, die Eigenschaft %1$s der Bean %2$s zu manipulieren, aufgetreten.
error.writing.beans=Ein nicht behebbarer Fehler ist beim Schreiben von Beans aufgetreten.
field.not.multivaluedmap=Das Bean-Feld muss org.apache.commons.collections4.MultiValuedMap implementieren.
field.not.primitive=Das Feld darf nur eines primitiven oder geh\u00fcllt primitiven Typs, BigDecimal, BigInteger oder String sein.
header.data.mismatch=Anzahl der Datenfelder stimmt nicht mit der Anzahl der \u00dcberschriften \u00fcberein.
header.data.mismatch.with.line.number=Fehler in Datensatz %d: Die Anzahl der Datenfelder stimmt mit der Anzahl der \u00dcberschriften nicht \u00fcberein.
header.error=Fehler beim Einlesen der CSV-\u00dcberschriftzeile!
header.name.bogus=Spalten\u00fcberschriften d\u00fcrfen nicht null oder leer sein, oder nur aus Leerzeichen bestehen.
header.nonexistant=Keine Spalte f\u00fcr \u00dcberschrift [%s] gefunden.
header.required.field.absent=Der \u00dcberschriftzeile fehlen die Pflichtfelder [%s]. Die Liste der gefundenen \u00dcberschriften enth\u00e4lt [%s].
header.unread=Die \u00dcberschriftzeile ist noch nicht eingelesen worden.
invalid.collection.type=Der angegebene Sammeltyp (Collection) ist entweder unbekannt oder implementiert java.util.Collection nicht: %s
invalid.multivaluedmap.type=Der angegebene \u00dcbersetzungstyp (Map) ist entweder unbekannt oder implementiert org.apache.commons.collections4.MultiValuedMap nicht: %s
invalid.number.pattern=Das Muster [%s] ist nach den Regeln von java.text.NumberFormat ungültig.
invalid.range.definition=Der angegebene Bereich [%s] ist ung\u00fcltig.
invalid.regex=Der angegebene regul\u00e4re Ausdruck ist ung\u00fcltig: %s
map.cannot.be.instantiated=Ein MultiValuedMap des Typs [%s] kann mit Null-Argument-Konstruktor nicht instantiiert werden.
matching=Stimmit mit [%s] \u00fcberein
multiline.limit.broken=Ein einziger Datensatz in der Eingabe sprengt die konfigurierte Obergrenze von %d Zeilen pro Datensatz.
multiple.required.field.empty=Die folgenden Pflichtfelder fehlten in einem Datensatz:
no.converter.specified=Ein Konvertierer (CsvConverter) w\u00e4re notwendig, ist aber nicht festgelegt.
nullary.constructor.not.allowed=Der argumentloser Konstruktor darf nie f\u00fcr die Klasse %s genutzt werden.
numberformat.not.decimalformat=Ein java.text.DecimalFormat wird in ConverterNumber benötigt, aber das JDK hat eine andere von java.text.NumberFormat abgeleitete Klasse ausgehändigt.
parsing.error=Fehler beim Parsen der CSV-Zeile: %1$d, Werte: %2$s
read.only.iterator=Dieser Iterator darf nicht ver\u00e4ndert werden.
reader.null=Der Reader darf nicht null sein.
required.field.empty=Feld '%s' ist ein Pflichtfeld, aber kein Wert wurde angegeben.
special.characters.must.differ=Das Trennzeichen, das Anf\u00fchrungszeichen, und das Escape-Zeichen m\u00fcssen sich alle unterscheiden!
specify.strategy.reader=Sowohl Mappingstrategie als auch CSVReader/Reader m\u00fcssen angegeben werden!
strategy.type.missing=Entweder eine Mappingstrategie oder der Typ der zu generierenden Bean muss angegeben werden.
strategy.undefined=IterableCSVToBeanBuilder konnte deshalb nicht instantiiert werden, weil keine MappingStrategy definiert ist.
type.before.header=Es muss erst ein Aufruf von MappingStrategy.setType() erfolgen, bevor MappingStrategy.generateHeader() aufgerufen werden kann.
type.unset=In der MappingStrategy wurde der Typ noch nicht gesetzt.
unassignable.collection.type=Die angegebene Collection-Implementierung (%s) kann dem Beanfeldtyp (%s) nicht zugewiesen werden.
unassignable.multivaluedmap.type=Die angegebene MultiValuedMap-Implementierung (%s) kann dem Beanfeldtyp (%s) nicht zugewiesen werden.
unparsable.number=Die Eingabe [%1$s] konnte nach dem Muster [%2$s] nicht als Zahl erkannt werden.
unterminated.quote=Unterminiertes Anf\u00fchrungszeichen am Ende einer CSV-Zeile. Anfang des verlorenen Textes: [%s]
xmlgregoriancalendar.impossible=Es war unm\u00f6glich, XMLGregorianCalendar zu instantiieren.